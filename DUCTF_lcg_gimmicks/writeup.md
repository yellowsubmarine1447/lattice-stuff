# Problem
https://github.com/DownUnderCTF/Challenges_2023_Public/tree/main/crypto/lcg-card-gimmicks/src

# Writeup
It was very satisfying to solve this problem. Unfortunately my solution code is still a little unreliable :D, but that's OK because I think it'll work after a few reruns, and at the end of the day I made use of quite a few important techniques I learnt!

This problem requires us to reverse engineer the seed from a Linear Congruential Generator (LCG) given 13 observations. LCG's are used in java.util.random, and this specific calculation is pretty much exactly the same one Java does to calculate random numbers (though with different parameters `A` and `C`).

Essentially, an LCG calculates $A\times s + C \bmod M$, where $s$ is our seed. This value then becomes the new seed, and is returned to the parent random number-getting function. The top 48 bits of this value is then extracted and used as the random integer (the bottom 16 bits tend to make the random number more "predictable"). To calculate a random number in the range [0, 54), this value is modded in 54 and returned as the value in the range.

After $n$ applications, the new seed will take on the value $A(A(\cdots) + C) + C)\cdots) + C$, which we can expand and use the geometric series formula to write as $A^ns + C\times\frac{A^n - 1}{A-1}$

Now, if we let $r$ be the value that we observe, then we may write each new seed we calculate as $A^ns + C\frac{A^n - 1}{A-1} + Mt_n = 2^{16}\times (54k_n + r_n) + h_n$, where $k_n, t_n$ are integers which represent subtractions to simulate the application of the modulus operator, and $h_n$ is the lower 16 bit number. If we rearrange this around, we can then express this problem as one where we wish to find small values of $h_n\le2^{16}$ so that the equality holds for all $n$, which we can then model as a CVP instance.

One issue with this construction is the appearance of "fake seeds". Essentially, because we are dealin with two different moduli ($M = 2^{64}$ and $2^{16}\times 54$) which are not multiples of one another, we could have a seed $s$ which satisfies this condition for some generated seed, but not specifically when $0 \le A^ns + C + Mt_n< 2^{64}$. That is to say, we must also assert the condition that every seed we generate is less than $2^64$. Matthew Bolan describes this problem and the solution to it at the end of [his video](https://www.youtube.com/watch?v=gsaV9gcLntM&t=2256s) on Minecraft seed finding in the Appendix section (though he uses a Branch and Bound to find multiple seeds that satisfy an inequality, rather than just one seed that's *close* to one bound of the inequality).

So now, we can model a CVP problem where:
- $A^ns + Mt_n$ is no more than $2^{64}$ away from $-C\frac{A^n - 1}{A-1}$
- $A^ns + Mt_n + 2^{16}\times54k_n$ is no more than $2^{16}$ away from $-C\frac{A^n - 1}{A-1}+2^{16}r_n$.

There was actually a LOT of issues I faced while coding this LLL setup up. For instance, to solve the CVP problem, I used Kannan embedding. However, this required me to embed the negative of the CVP values I described previous (so $C\frac{A^n - 1}{A-1}$ for example, instead of its negative). Also, I messed up my setup of the matrix, which took up quite a bit more time debugging.

But perhaps the biggest issue I faced came after fixing all of this, where the random numbers generated by my seed appeared to be close to the observed values but not quite correctly. After a lot of debugging, this turned out to be because of negative seeds and negative observed values. Essentially, because of the modular arithmetic, I don't make any restrictions on whether or not the generated seed or $h_n$ is negative. This means that seeds bigger than $2^63$ will tend to "want" to be negative, since that's closer to $0$ (recall the LLL algorithm tends to generate small vectors). However, this messes up with the $2^{16}\times 54$ modulus in a similar way described to the "fake seeds" issue.

To fix this, I made use of a technique that I learnt from implementing the Hidden Subset Sum problem to coerce positive integers to be the result of these values. This is done by subtracting half of each upper bound from the CVP: this makes it so that, for example, generated seeds bigger than $2^63$ will be subtracted by $2^63$ and maintain a good distance from $0$, whereas if they were to become negative, they would stray further away from $0$.

The code now generates correct values a lot more frequently now, and even incorrect seeds don't stray too far from the observed values (this still happens because the LLL only probabilistically finds short vectors, and so we could still create generated seeds which are negative or bigger than $2^64$, or $h_n$ values which are negative or bigger than $2^16$.
